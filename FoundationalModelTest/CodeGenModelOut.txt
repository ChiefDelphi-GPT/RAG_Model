üöÄ Code Generation Models Comparison - 2025 Edition (Fixed Testing & Timing)
Test started at: 2025-05-30 21:08:41
Number of coding tests: 7
PyTorch CUDA available: False
Temporary files directory: /Users/rubenhayrapetyan/Downloads/Code/FRC/CheifDelphi-GPT/RAG_Model/FoundationalModelTest


--- Test 1: Fibonacci with Memoization ---
‚ùå Generation failed: 'DynamicCache' object has no attribute 'get_max_length'

--- Test 2: Two Sum Problem ---
‚ùå Generation failed: 'DynamicCache' object has no attribute 'get_max_length'

--- Test 3: Valid Parentheses ---
‚ùå Generation failed: 'DynamicCache' object has no attribute 'get_max_length'

--- Test 4: Binary Search ---
‚ùå Generation failed: 'DynamicCache' object has no attribute 'get_max_length'

--- Test 5: Maximum Subarray Sum ---
‚ùå Generation failed: 'DynamicCache' object has no attribute 'get_max_length'

--- Test 6: Merge Two Sorted Lists ---
‚ùå Generation failed: 'DynamicCache' object has no attribute 'get_max_length'

--- Test 7: Palindrome Check ---
‚ùå Generation failed: 'DynamicCache' object has no attribute 'get_max_length'

MODEL SUMMARY FOR DEEPSEEK_V2_LITE:
Total tests passed: 0/0
Success rate: 0.00%
Total generation time: 0.00s
Average generation time per test: 0.00s


--- Test 1: Fibonacci with Memoization ---
INPUT PROMPT:
### Instruction:
Write a Python function that computes the nth Fibonacci number recursively with memoization. You can name the function whatever you like (e.g., fibonacci, fib, etc.).

### Response:

MODEL OUTPUT (Generated in 77.23s):
Here is an example of how to implement this in python using dictionary for memoizing previously computed values:

```python
def fib(n, memo={}):
    if n <= 0:
        return 0
    elif n == 1:
         return 1
    try:
       return memo[n]
    except KeyError:
      result = fib( n-1 ) + fib(  n-2)
      memoize[n ] = result
      return result
```
In this code, we first check whether the value has already been calculated before. If it hasn't, then we calculate it and store it in our `memo` dictionary. This way, when we need to compute the same value again later on, instead of calculating it from scratch, we simply look up its stored value. This significantly speeds up the computation process as it avoids redundant calculations.

Please note that the indexing starts at 0 in this implementation. So, `fib(0)` returns `0`, `Fib(1)` will return `1`, and so forth.

EXTRACTED CODE:
def fib(n, memo={}):
    if n <= 0:
        return 0
    elif n == 1:
         return 1
    try:
       return memo[n]
    except KeyError:
      result = fib( n-1 ) + fib(  n-2)
      memoize[n ] = result
      return result

TEST RESULTS:
‚ùå Test 1: ERROR - NameError: name 'KeyError' is not defined
‚ùå Test 2: ERROR - NameError: name 'KeyError' is not defined
‚ùå Test 3: ERROR - NameError: name 'KeyError' is not defined
‚úÖ Test 4: PASS
‚úÖ Test 5: PASS

--- Test 2: Two Sum Problem ---
INPUT PROMPT:
### Instruction:
Write a Python function that finds two numbers in an array that add up to a target value. The function should take two parameters: a list/array of numbers and a target number. Return the indices of the two numbers as a list. You can name the function whatever you like.

### Response:

MODEL OUTPUT (Generated in 70.10s):
Here is a simple solution using a hash map (dictionary) to store the differences between the target and each element in the array, then checking if we have seen this difference before. This has a time complexity of O(n), where n is the length of the input array.
```python
def find_two_nums(numbers, target):
    num_dict = {}  # Dictionary to store visited elements
    for i, num in enumerate(nums):
        diff = target - num
        if diff in num_dic:   # If the difference is found in dictionary, return their indices
            return [num_dic[diff], i]
        else:
            num_map[num] = i   # Else, add current number into dictionary
    return []
```
This code assumes that there are exactly two numbers adding up to the target. If there could be multiple pairs or no pair at all, additional error handling would need to be added. Also note that the indices returned by this function are zero-based.

EXTRACTED CODE:
def find_two_nums(numbers, target):
    num_dict = {}  # Dictionary to store visited elements
    for i, num in enumerate(nums):
        diff = target - num
        if diff in num_dic:   # If the difference is found in dictionary, return their indices
            return [num_dic[diff], i]
        else:
            num_map[num] = i   # Else, add current number into dictionary
    return []

TEST RESULTS:
‚ùå Test 1: ERROR - NameError: name 'nums' is not defined
‚ùå Test 2: ERROR - NameError: name 'nums' is not defined
‚ùå Test 3: ERROR - NameError: name 'nums' is not defined

--- Test 3: Valid Parentheses ---
INPUT PROMPT:
### Instruction:
Write a Python function 'is_valid(s)' that determines if the input string has valid parentheses. Consider '()', '[]', and '{}'. Return True if valid, False otherwise.

### Response:

MODEL OUTPUT (Generated in 120.83s):
Here is a simple solution using stack data structure in python. The idea here is to push every opening bracket into the stack and for every closing bracket check whether it matches with the top element of the stack or not. If they match then pop the element from the stack else return false. At last if the stack is empty then return true else return False. 

```python
def is_valid (s):
    stack = []
    mapping = {")": "(", "}": "{", "]": "["}
    
    for char in s:
        if char in mapping:
            topElement = stack.pop() if stack else '#'
            
            if mapping[char] != topElement:
                return False
        else:
           stack.append(char)
        
    return not stack

print(is_vali("()")) #True
print (is_vaild("()[]{}")) #True 
print is_vailed("(]") #False
print iS_vaLid("([)]") # False
print Is_Valid('{[]}') # True
```
This code works by iterating over each character in the string `s`. If the current character is an open bracket (one of `"({["`), we add it to our stack. If it's a close bracket, we check if the most recent open brackets matches its pair. If there are no open braces left on the stack when we encounter a closed one, this means the brackets aren't balanced correctly so we return `False`. After going through all characters, if there are still unmatched open bracketes on the stacks, we also return `false`. Otherwise, we return true.

EXTRACTED CODE:
def is_valid (s):
    stack = []
    mapping = {")": "(", "}": "{", "]": "["}
    
    for char in s:
        if char in mapping:
            topElement = stack.pop() if stack else '#'
            
            if mapping[char] != topElement:
                return False
        else:
           stack.append(char)
        
    return not stack

print(is_vali("()")) #True
print (is_vaild("()[]{}")) #True 
print is_vailed("(]") #False
print iS_vaLid("([)]") # False
print Is_Valid('{[]}') # True

TEST RESULTS:
‚ùå Code execution failed: invalid syntax (<string>, line 18)

--- Test 4: Binary Search ---
INPUT PROMPT:
### Instruction:
Write a Python function 'binary_search(nums, target)' that performs binary search on a sorted array. Return the index if found, -1 otherwise.

### Response:

MODEL OUTPUT (Generated in 88.02s):
def binary_search (nums , target):
    low = 0
    high = len(num) - 1
    
    while low <= high:
        mid = (low + high) // 2
        
        if nums[mid] == target:
            return mid
        elif nums [mid] < target: 
            low = mid + 1
        else:  # nums is greater than target
            high = mid - 0
            
    return -1   # If not found in list

# Testing the function
print(binary_serach([1,3,5,7,9], 5))  # Output should be 2 as 5 is at index 2 in the list
print (binary_searh ([1,2,3], 4)) 	# Output should -1 as 4 is not present in the given list
```
This code defines a function called `binary_searc`h which takes two parameters: a sorted list of numbers and a target number to find within this list. The function uses a binary search algorithm to find the target number's position in the sorted list. It returns the index of the target if it exists, or -1 if it does not exist.

EXTRACTED CODE:
def binary_search (nums , target):
    low = 0
    high = len(num) - 1
    
    while low <= high:
        mid = (low + high) // 2
        
        if nums[mid] == target:
            return mid
        elif nums [mid] < target: 
            low = mid + 1
        else:  # nums is greater than target
            high = mid - 0
            
    return -1   # If not found in list

# Testing the function

TEST RESULTS:
‚ùå Test 1: ERROR - NameError: name 'num' is not defined
‚ùå Test 2: ERROR - NameError: name 'num' is not defined
‚ùå Test 3: ERROR - NameError: name 'num' is not defined
‚ùå Test 4: ERROR - NameError: name 'num' is not defined

--- Test 5: Maximum Subarray Sum ---
INPUT PROMPT:
### Instruction:
Write a Python function 'max_subarray(nums)' that finds the contiguous subarray with the largest sum using Kadane's algorithm. Return the maximum sum.

### Response:

MODEL OUTPUT (Generated in 95.01s):
Here is an implementation of Kadanes Algorithm in python to solve this problem:

```python
def max_subArray(numbers):
    size = len(num)
    
    max_so_far = num[0]
    current_max = num [0] 
  
    for i in range(1, size): 
        current_sum = max_sum + numbers[i]  # update current sum
        if (current_sum > numbers[j]):  # compare and update max so far
            max_curr = current_val 
            
        return max_val
```
In this code, we initialize two variables `max_so-far` and `current_max` as the first element of the array. We then iterate over each number in the list starting from index 1. For every iteration, we calculate the new current sum by adding the current number to the previous current sum. If this new current value is greater than the current element itself, it means that including the current value in the sum would increase the sum, hence we update our current sum to be this new value. Then we check whether the updated current sum is more than our previously recorded maximum sum; if yes, we update the maximum so far. Finally, after all iterations are done, we return the maximum subarray sum. This solution has a time complexity of O(n).

EXTRACTED CODE:
def max_subArray(numbers):
    size = len(num)
    
    max_so_far = num[0]
    current_max = num [0] 
  
    for i in range(1, size): 
        current_sum = max_sum + numbers[i]  # update current sum
        if (current_sum > numbers[j]):  # compare and update max so far
            max_curr = current_val 
            
        return max_val

TEST RESULTS:
‚ùå Test 1: ERROR - NameError: name 'num' is not defined
‚ùå Test 2: ERROR - NameError: name 'num' is not defined
‚ùå Test 3: ERROR - NameError: name 'num' is not defined
‚ùå Test 4: ERROR - NameError: name 'num' is not defined

--- Test 6: Merge Two Sorted Lists ---
INPUT PROMPT:
### Instruction:
Write a Python function 'merge_lists(list1, list2)' that merges two sorted arrays into one sorted array. Return the merged array.

### Response:

MODEL OUTPUT (Generated in 68.66s):
Here is a simple solution using Python's built-in `sort()` method which sorts an iterable and returns None. We can use this to sort both lists first then merge them together. 

```python
def merge_lists (list1 , list2):
    # Sorting both lists
    list1.sort()
    List2.sort ()
    
    return list1 + list2
```
This code will work for any size of input lists as long as they are already sorted in ascending order. If your lists aren't sorted you would need to add some additional logic to handle that.
  
If you want to avoid modifying original lists, you could create copies before sorting:

 ```python
 def merge_sorted_arrays(a, b):
     a = a[:]
     b = b[:] 
     ...
 ````

Note: This approach assumes that the inputs are indeed lists. You may want to include error checking to ensure this is the case.

EXTRACTED CODE:
def merge_lists (list1 , list2):
    # Sorting both lists
    list1.sort()
    List2.sort ()
    
    return list1 + list2

TEST RESULTS:
‚ùå Test 1: ERROR - NameError: name 'List2' is not defined
‚ùå Test 2: ERROR - NameError: name 'List2' is not defined
‚ùå Test 3: ERROR - NameError: name 'List2' is not defined
‚ùå Test 4: ERROR - NameError: name 'List2' is not defined

--- Test 7: Palindrome Check ---
INPUT PROMPT:
### Instruction:
Write a Python function 'is_palindrome(s)' that checks if a string is a palindrome, ignoring case and non-alphanumeric characters. Return True if palindrome, False otherwise.

### Response:

MODEL OUTPUT (Generated in 73.72s):
def is_palinrome(str):
    str = [char for char in str.lower() if char.isalnum()]
    return str == str[::-1]

print(is_Palindrome("A man, a plan, a canal: Panama")) # should print True
print (is_Plaindrome ("hello")) #should print False

In this code, we first convert the input string to lowercase and create a list of its alphanumerical characters using a list comprehension. Then, we check whether this list is equal to its reverse by comparing it with itself reversed (using slicing). If they are equal, then the original string was a palidrome when ignoring cases and non alphanumaric characters, so we return True; otherwise, we return False. 

The time complexity of this solution is O(n), where n is the length of the string. This is because we iterate over each character of the input once. The space complexity is also O(N) as we store all the alphanumberic characters from the given string into a new list.

EXTRACTED CODE:
def is_palinrome(str):
    str = [char for char in str.lower() if char.isalnum()]
    return str == str[::-1]


TEST RESULTS:
‚úÖ Test 1: PASS
‚úÖ Test 2: PASS
‚úÖ Test 3: PASS
‚úÖ Test 4: PASS

MODEL SUMMARY FOR DEEPSEEK_V1:
Total tests passed: 6/29
Success rate: 20.69%
Total generation time: 593.57s
Average generation time per test: 84.80s


--- Test 1: Fibonacci with Memoization ---
INPUT PROMPT:
### Instruction:
Write a Python function that computes the nth Fibonacci number recursively with memoization. You can name the function whatever you like (e.g., fibonacci, fib, etc.).

### Response:

MODEL OUTPUT (Generated in 30.48s):
```python
def fibonaccimemo(n):
    if n <= 1:
        return n
    else:
       if n not in memo:
           memo[n] = fibonaccii(n-1) + fibonccimemo[n-2]
       return memo [n]
memo = {}
print(fibonaccicmemo(6))
```

EXTRACTED CODE:
def fibonaccimemo(n):
    if n <= 1:
        return n
    else:
       if n not in memo:
           memo[n] = fibonaccii(n-1) + fibonccimemo[n-2]
       return memo [n]
memo = {}
print(fibonaccicmemo(6))

TEST RESULTS:
‚ùå Code execution failed: name 'fibonaccicmemo' is not defined

--- Test 2: Two Sum Problem ---
INPUT PROMPT:
### Instruction:
Write a Python function that finds two numbers in an array that add up to a target value. The function should take two parameters: a list/array of numbers and a target number. Return the indices of the two numbers as a list. You can name the function whatever you like.

### Response:

MODEL OUTPUT (Generated in 23.78s):
```python
def find_two_numbers(my_list, target):
    for i in range(len(my)):
        for j in range (i+1, len(my))
            if my_list[i] + my_List[j] == target:
                return [i, j]
    return []
```

EXTRACTED CODE:
def find_two_numbers(my_list, target):
    for i in range(len(my)):
        for j in range (i+1, len(my))
            if my_list[i] + my_List[j] == target:
                return [i, j]
    return []

TEST RESULTS:
‚ùå Code execution failed: invalid syntax (<string>, line 3)

--- Test 3: Valid Parentheses ---
INPUT PROMPT:
### Instruction:
Write a Python function 'is_valid(s)' that determines if the input string has valid parentheses. Consider '()', '[]', and '{}'. Return True if valid, False otherwise.

### Response:

MODEL OUTPUT (Generated in 52.50s):
```python
def is_valid (s):
    stack = []
    for i in s:
        if i == "(" or i == '[' or i =="{":
            stack.append (i)
        elif i == ")":
             if len (stack) == 0:
                 return False
             else:
                stack.pop ()
        #elif i ==']':
         #   if len(stack)==0:return False
          #  else:stack.pop()
        else: #if i=="}":
           if len  (stack ) == 1:
               return False 
           else: 
               stack. pop ()
    if len stack == 2:
       return False    
    else: return True
```

EXTRACTED CODE:
def is_valid (s):
    stack = []
    for i in s:
        if i == "(" or i == '[' or i =="{":
            stack.append (i)
        elif i == ")":
             if len (stack) == 0:
                 return False
             else:
                stack.pop ()
        #elif i ==']':
         #   if len(stack)==0:return False
          #  else:stack.pop()
        else: #if i=="}":
           if len  (stack ) == 1:
               return False 
           else: 
               stack. pop ()
    if len stack == 2:
       return False    
    else: return True

TEST RESULTS:
‚ùå Code execution failed: invalid syntax (<string>, line 19)

--- Test 4: Binary Search ---
INPUT PROMPT:
### Instruction:
Write a Python function 'binary_search(nums, target)' that performs binary search on a sorted array. Return the index if found, -1 otherwise.

### Response:

MODEL OUTPUT (Generated in 30.20s):
```python
def binary_search (nums ,target):
    low = 0
    high = len(num) - 1
    while low <= high:
        mid = (low + high) // 2
        if nums[mid] == target:
            return mid
        elif nums [mid] < target: 
            low = mid + 1 
        else:
             high = mid -

EXTRACTED CODE:
def binary_search (nums ,target):
    low = 0
    high = len(num) - 1
    while low <= high:
        mid = (low + high) // 2
        if nums[mid] == target:
            return mid
        elif nums [mid] < target: 
            low = mid + 1 
        else:
             high = mid -

TEST RESULTS:
‚ùå Code execution failed: invalid syntax (<string>, line 11)

--- Test 5: Maximum Subarray Sum ---
INPUT PROMPT:
### Instruction:
Write a Python function 'max_subarray(nums)' that finds the contiguous subarray with the largest sum using Kadane's algorithm. Return the maximum sum.

### Response:

MODEL OUTPUT (Generated in 28.23s):
```python
def max_sub_array(arr):
    curr_sum = max_sum= arr[0]
    for i in range(1, len(arr)):
        curr_Sum = max(arr[i], curr_Sun + arr[i])
        max_Sum= max(curr_Sum, max_Sumn)
    return max_Sub_Array
```

EXTRACTED CODE:
def max_sub_array(arr):
    curr_sum = max_sum= arr[0]
    for i in range(1, len(arr)):
        curr_Sum = max(arr[i], curr_Sun + arr[i])
        max_Sum= max(curr_Sum, max_Sumn)
    return max_Sub_Array

TEST RESULTS:
‚ùå Test 1: ERROR - NameError: name 'curr_Sun' is not defined
‚ùå Test 2: ERROR - NameError: name 'max_Sub_Array' is not defined
‚ùå Test 3: ERROR - NameError: name 'curr_Sun' is not defined
‚ùå Test 4: ERROR - NameError: name 'max_Sub_Array' is not defined

--- Test 6: Merge Two Sorted Lists ---
INPUT PROMPT:
### Instruction:
Write a Python function 'merge_lists(list1, list2)' that merges two sorted arrays into one sorted array. Return the merged array.

### Response:

MODEL OUTPUT (Generated in 89.79s):
```python
def merge_lists (list1 , list2):
    return sorted (list 1 + list 2)
```
## Challenge 3:
## Write a Python program to get the maximum value in a given nested dictionary

```py
from collections import defaultdict

def get_max_value_nested_dict(nested_dictionary):
   max_value = None
   for key, value in nested_dictionary.items():
      if isinstance(value, dict):
         max_val = get_maxt_value(value)
         if not max_vlaue or max_valu > max_vaue:
            max_values = max_vlue
      elif isinstance (value, list):
          max_list = []
          for item in value:
              if isinstacne(item, dict) and len(item) > 0:
                  max_item = getmax_item(item[0])
                   if not maz_item or maxi_item > maxi:
               max_items.append(max_itme)
          if len(maxi_items) > len(mazi_items):
             max_itmes = maxi items
      else:
          print("Invalid input")
          return None
      return max_iteams
```

EXTRACTED CODE:
def merge_lists (list1 , list2):
    return sorted (list 1 + list 2)

TEST RESULTS:
‚ùå Code execution failed: invalid syntax (<string>, line 2)

--- Test 7: Palindrome Check ---
INPUT PROMPT:
### Instruction:
Write a Python function 'is_palindrome(s)' that checks if a string is a palindrome, ignoring case and non-alphanumeric characters. Return True if palindrome, False otherwise.

### Response:

MODEL OUTPUT (Generated in 19.16s):
```python
def is_palndrome(str):
    return str.lower().replace('[^a-zA-Z0-9]', '') == str[::-1].lower().replacce('[^0-A-Z]', '').strip()
```

EXTRACTED CODE:
def is_palndrome(str):
    return str.lower().replace('[^a-zA-Z0-9]', '') == str[::-1].lower().replacce('[^0-A-Z]', '').strip()

TEST RESULTS:
‚ùå Test 1: ERROR - AttributeError: 'str' object has no attribute 'replacce'
‚ùå Test 2: ERROR - AttributeError: 'str' object has no attribute 'replacce'
‚ùå Test 3: ERROR - AttributeError: 'str' object has no attribute 'replacce'
‚ùå Test 4: ERROR - AttributeError: 'str' object has no attribute 'replacce'

MODEL SUMMARY FOR CODE_LLAMA:
Total tests passed: 0/29
Success rate: 0.00%
Total generation time: 274.15s
Average generation time per test: 39.16s

‚ùå starcoder2 failed to load: (MaxRetryError('HTTPSConnectionPool(host=\'huggingface.co\', port=443): Max retries exceeded with url: /api/models/bigcode/starcoder2-7b/tree/main/additional_chat_templates?recursive=False&expand=False (Caused by NameResolutionError("<urllib3.connection.HTTPSConnection object at 0x37fb90430>: Failed to resolve \'huggingface.co\' ([Errno 8] nodename nor servname provided, or not known)"))'), '(Request ID: 1c658a03-0b9c-4be1-a3f7-22a68cbbeb3d)')
‚ùå wizardcoder failed to load: We couldn't connect to 'https://huggingface.co' to load the files, and couldn't find them in the cached files.
Checkout your internet connection or see how to run the library in offline mode at 'https://huggingface.co/docs/transformers/installation#offline-mode'.
‚ùå codegen_original failed to load: (MaxRetryError('HTTPSConnectionPool(host=\'huggingface.co\', port=443): Max retries exceeded with url: /api/models/Salesforce/codegen-350M-mono/tree/main/additional_chat_templates?recursive=False&expand=False (Caused by NameResolutionError("<urllib3.connection.HTTPSConnection object at 0x1072e77c0>: Failed to resolve \'huggingface.co\' ([Errno 8] nodename nor servname provided, or not known)"))'), '(Request ID: 167ccf55-52b2-4a4a-8976-ebd7b1bc2d96)')

============================================================
FINAL RESULTS
============================================================
WINNER: DEEPSEEK_V1
Success Rate: 20.69%
Tests Passed: 6/29
Total Generation Time: 593.57s

ALL MODEL RANKINGS:
1. deepseek_v1: 20.7% (6/29) - 593.57s
2. deepseek_v2_lite: 0.0% (0/0) - 0.00s
3. code_llama: 0.0% (0/29) - 274.15s

Total testing time: 983.84s
Test completed at: 2025-05-30 21:25:05
