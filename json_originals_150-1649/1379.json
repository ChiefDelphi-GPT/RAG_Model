{"data":"{\"post_stream\":{\"posts\":[{\"id\":3554300,\"name\":\"Daniel McLaughlin\",\"username\":\"Pieyama_Pieman\",\"avatar_template\":\"/user_avatar/www.chiefdelphi.com/pieyama_pieman/{size}/242065_2.png\",\"created_at\":\"2025-03-11T18:09:13.657Z\",\"cooked\":\"\\u003cp\\u003eHello,\\u003c/p\\u003e\\n\\u003cp\\u003eI’m struggling to make sense of my team’s code. What I want is to supply the tx value from Limelight as the error used in place of a joystick heading, if that makes sense. All I need is the robot to point the camera in the direction of the tag, but \\u003cspan class=\\\"abbreviation\\\"\\u003eYAGSL\\u003ctemplate class=\\\"tooltiptext\\\" data-text=\\\"Yet Another Generic Swerve Library\\\"\\u003e\\u003c/template\\u003e\\u003c/span\\u003e is proving too much for me to parse by myself.\\u003c/p\\u003e\\n\\u003cp\\u003eAny help is appreciated.\\u003c/p\\u003e\\n\\u003cp\\u003eRobotContainer.java\\u003c/p\\u003e\\n\\u003cpre\\u003e\\u003ccode class=\\\"lang-auto\\\"\\u003e\\npackage frc.robot;\\n\\nimport com.pathplanner.lib.auto.NamedCommands;\\n\\nimport frc.robot.subsystems.vision.Limelight;\\nimport edu.wpi.first.cameraserver.CameraServer;\\nimport edu.wpi.first.cscore.UsbCamera;\\nimport edu.wpi.first.wpilibj.DriverStation;\\nimport edu.wpi.first.wpilibj.Filesystem;\\nimport edu.wpi.first.wpilibj.Joystick;\\nimport edu.wpi.first.wpilibj.RobotBase;\\nimport edu.wpi.first.wpilibj2.command.Command;\\nimport edu.wpi.first.wpilibj2.command.InstantCommand;\\nimport edu.wpi.first.wpilibj2.command.RunCommand;\\nimport edu.wpi.first.wpilibj2.command.button.CommandXboxController;\\nimport edu.wpi.first.wpilibj2.command.Commands;\\nimport frc.robot.Constants.OperatorConstants;\\nimport frc.robot.commands.Claw.IntakeCommand;\\nimport frc.robot.commands.Claw.RotationCommand;\\nimport frc.robot.commands.Climber.ClimberCommand;\\nimport frc.robot.commands.Elevator.ElevatorCommand;\\nimport frc.robot.commands.swervedrive.drivebase.EuroVision;\\nimport frc.robot.subsystems.Climber.ClimberSubsystem;\\nimport frc.robot.subsystems.Elevator.ElevatorSubsystem;\\nimport frc.robot.subsystems.claw.IntakeSubsystem;\\nimport frc.robot.subsystems.claw.RotationSubsystem;\\nimport frc.robot.subsystems.swervedrive.SwerveSubsystem;\\nimport frc.robot.subsystems.vision.Limelight;\\n\\nimport java.io.File;\\nimport swervelib.SwerveInputStream;\\n\\npublic class RobotContainer {\\n\\n\\n        private final SwerveSubsystem drivebase = new SwerveSubsystem(new File(Filesystem.getDeployDirectory(),\\n                        \\\"swerve/neo\\\"));\\n\\n        private final RotationSubsystem rotationSubsystem = new RotationSubsystem();\\n        private final IntakeSubsystem intakeSubsystem = new IntakeSubsystem();\\n        private final ElevatorSubsystem elevatorSubsystem = new ElevatorSubsystem();\\n        private final ClimberSubsystem climberSubsystem = new ClimberSubsystem();\\n        private final Limelight m_Limelight = new Limelight();\\n\\n        SwerveInputStream driveAngularVelocity = SwerveInputStream.of(drivebase.getSwerveDrive(),\\n                        () -\\u0026gt; Constants.OperatorConstants.driverXbox.getLeftY() * -1,\\n                        () -\\u0026gt; Constants.OperatorConstants.driverXbox.getLeftX() * -1)\\n                        .withControllerRotationAxis(Constants.OperatorConstants.driverXbox::getRightX)\\n                        .deadband(OperatorConstants.DEADBAND)\\n                        .scaleTranslation(0.8)\\n                        .allianceRelativeControl(true);\\n\\n        SwerveInputStream driveDirectAngle = driveAngularVelocity.copy()\\n                        .withControllerHeadingAxis(Constants.OperatorConstants.driverXbox::getRightX,\\n                                        Constants.OperatorConstants.driverXbox::getRightY)\\n                        .headingWhile(true);\\n\\n        SwerveInputStream driveRobotOriented = driveAngularVelocity.copy().robotRelative(true)\\n                        .allianceRelativeControl(false);\\n\\n        SwerveInputStream driveAngularVelocityKeyboard = SwerveInputStream.of(drivebase.getSwerveDrive(),\\n                        () -\\u0026gt; -Constants.OperatorConstants.driverXbox.getLeftY() * 1,\\n                        () -\\u0026gt; -Constants.OperatorConstants.driverXbox.getLeftX() * 1)\\n                        .withControllerRotationAxis(() -\\u0026gt; Constants.OperatorConstants.driverXbox.getRawAxis(\\n                                        2))\\n                        .deadband(OperatorConstants.DEADBAND)\\n                        .scaleTranslation(0.8)\\n                        .allianceRelativeControl(true);\\n\\n        SwerveInputStream driveDirectAngleKeyboard = driveAngularVelocityKeyboard.copy()\\n                        .withControllerHeadingAxis(() -\\u0026gt; Math.sin(\\n                                        Constants.OperatorConstants.driverXbox.getRawAxis(\\n                                                        2) *\\n                                                        Math.PI)\\n                                        *\\n                                        (Math.PI *\\n                                                        2),\\n                                        () -\\u0026gt; Math.cos(\\n                                                        Constants.OperatorConstants.driverXbox.getRawAxis(\\n                                                                        2) *\\n                                                                        Math.PI)\\n                                                        *\\n                                                        (Math.PI *\\n                                                                        2))\\n                        .headingWhile(true);\\n\\n        public RobotContainer() {\\n                configureBindings();\\n                DriverStation.silenceJoystickConnectionWarning(true);\\n                NamedCommands.registerCommand(\\\"test\\\", Commands.print(\\\"I EXIST\\\"));\\n                rotationSubsystem.setDefaultCommand(new RotationCommand(rotationSubsystem));\\n                intakeSubsystem.setDefaultCommand(new IntakeCommand(intakeSubsystem));\\n                elevatorSubsystem.setDefaultCommand(new ElevatorCommand(elevatorSubsystem));\\n                climberSubsystem.setDefaultCommand(new ClimberCommand(climberSubsystem));\\n                m_Limelight.setDefaultCommand(\\n        \\n                new RunCommand(\\n                () -\\u0026gt;\\n                m_Limelight.periodic(), m_Limelight)\\n        );\\n        }\\n\\n        private void configureBindings() {\\n                Command driveFieldOrientedDirectAngle = drivebase.driveFieldOriented(driveDirectAngle);\\n                Command driveFieldOrientedAnglularVelocity = drivebase.driveFieldOriented(driveAngularVelocity);\\n                Command driveRobotOrientedAngularVelocity = drivebase.driveFieldOriented(driveRobotOriented);\\n                Command driveSetpointGen = drivebase.driveWithSetpointGeneratorFieldRelative(\\n                                driveDirectAngle);\\n                Command driveFieldOrientedDirectAngleKeyboard = drivebase.driveFieldOriented(driveDirectAngleKeyboard);\\n                Command driveFieldOrientedAnglularVelocityKeyboard = drivebase\\n                                .driveFieldOriented(driveAngularVelocityKeyboard);\\n                Command driveSetpointGenKeyboard = drivebase.driveWithSetpointGeneratorFieldRelative(\\n                                driveDirectAngleKeyboard);\\n\\n                if (RobotBase.isSimulation()) {\\n                        drivebase.setDefaultCommand(driveFieldOrientedDirectAngleKeyboard);\\n                } else {\\n                        drivebase.setDefaultCommand(driveRobotOrientedAngularVelocity);\\n                }\\n\\n        }\\n\\n        public Command getAutonomousCommand() {\\n                return drivebase.getAutonomousCommand(\\\"New Auto\\\");\\n        }\\n\\n        public void setMotorBrake(boolean brake) {\\n                drivebase.setMotorBrake(brake);\\n        }\\n}\\n\\n\\u003c/code\\u003e\\u003c/pre\\u003e\\n\\u003cp\\u003eSwerve Subsystems\\u003c/p\\u003e\\n\\u003cpre\\u003e\\u003ccode class=\\\"lang-auto\\\"\\u003e// Copyright (c) FIRST and other WPILib contributors.\\n// Open Source Software; you can modify and/or share it under the terms of\\n// the WPILib BSD license file in the root directory of this project.\\n\\npackage frc.robot.subsystems.swervedrive;\\n\\nimport static edu.wpi.first.units.Units.Meter;\\n\\nimport com.pathplanner.lib.auto.AutoBuilder;\\nimport com.pathplanner.lib.commands.PathPlannerAuto;\\nimport com.pathplanner.lib.commands.PathfindingCommand;\\nimport com.pathplanner.lib.config.PIDConstants;\\nimport com.pathplanner.lib.config.RobotConfig;\\nimport com.pathplanner.lib.controllers.PPHolonomicDriveController;\\nimport com.pathplanner.lib.path.PathConstraints;\\nimport com.pathplanner.lib.path.PathPlannerPath;\\nimport com.pathplanner.lib.util.DriveFeedforwards;\\nimport com.pathplanner.lib.util.swerve.SwerveSetpoint;\\nimport com.pathplanner.lib.util.swerve.SwerveSetpointGenerator;\\nimport edu.wpi.first.apriltag.AprilTagFieldLayout;\\nimport edu.wpi.first.apriltag.AprilTagFields;\\nimport edu.wpi.first.math.controller.SimpleMotorFeedforward;\\nimport edu.wpi.first.math.geometry.Pose2d;\\nimport edu.wpi.first.math.geometry.Pose3d;\\nimport edu.wpi.first.math.geometry.Rotation2d;\\nimport edu.wpi.first.math.geometry.Translation2d;\\nimport edu.wpi.first.math.kinematics.ChassisSpeeds;\\nimport edu.wpi.first.math.kinematics.SwerveDriveKinematics;\\nimport edu.wpi.first.math.trajectory.Trajectory;\\nimport edu.wpi.first.math.util.Units;\\nimport edu.wpi.first.wpilibj.DriverStation;\\nimport edu.wpi.first.wpilibj.DriverStation.Alliance;\\nimport edu.wpi.first.wpilibj.Timer;\\nimport edu.wpi.first.wpilibj2.command.Command;\\nimport edu.wpi.first.wpilibj2.command.Commands;\\nimport edu.wpi.first.wpilibj2.command.SubsystemBase;\\nimport edu.wpi.first.wpilibj2.command.sysid.SysIdRoutine.Config;\\nimport frc.robot.Constants;\\nimport java.io.File;\\nimport java.io.IOException;\\nimport java.util.Arrays;\\nimport java.util.Optional;\\nimport java.util.concurrent.atomic.AtomicReference;\\nimport java.util.function.DoubleSupplier;\\nimport java.util.function.Supplier;\\nimport org.json.simple.parser.ParseException;\\nimport org.photonvision.targeting.PhotonPipelineResult;\\nimport swervelib.SwerveController;\\nimport swervelib.SwerveDrive;\\nimport swervelib.SwerveDriveTest;\\nimport swervelib.math.SwerveMath;\\nimport swervelib.parser.SwerveControllerConfiguration;\\nimport swervelib.parser.SwerveDriveConfiguration;\\nimport swervelib.parser.SwerveParser;\\nimport swervelib.telemetry.SwerveDriveTelemetry;\\nimport swervelib.telemetry.SwerveDriveTelemetry.TelemetryVerbosity;\\n\\npublic class SwerveSubsystem extends SubsystemBase {\\n\\n  /**\\n   * Swerve drive object.\\n   */\\n  private final SwerveDrive swerveDrive;\\n  /**\\n   * AprilTag field layout.\\n   */\\n  private final AprilTagFieldLayout aprilTagFieldLayout = AprilTagFieldLayout.loadField(AprilTagFields.k2024Crescendo);\\n  /**\\n   * Enable vision odometry updates while driving.\\n   */\\n\\n  /**\\n   * PhotonVision class to keep an accurate odometry.\\n   */\\n\\n  /**\\n   * Initialize {@link SwerveDrive} with the directory provided.\\n   *\\n   * @param directory Directory of swerve drive config files.\\n   */\\n  public SwerveSubsystem(File directory) {\\n    // Configure the Telemetry before creating the SwerveDrive to avoid unnecessary\\n    // objects being created.\\n    SwerveDriveTelemetry.verbosity = TelemetryVerbosity.HIGH;\\n    try {\\n      swerveDrive = new SwerveParser(directory).createSwerveDrive(Constants.MAX_SPEED,\\n          new Pose2d(new Translation2d(Meter.of(1),\\n              Meter.of(4)),\\n              Rotation2d.fromDegrees(0)));;\\n\\n      // Alternative method if you don't want to supply the conversion factor via JSON\\n      // files.\\n      // swerveDrive = new SwerveParser(directory).createSwerveDrive(maximumSpeed,\\n      // angleConversionFactor, driveConversionFactor);\\n    } catch (Exception e) {\\n      throw new RuntimeException(e);\\n    }\\n    swerveDrive.setHeadingCorrection(false); // Heading correction should only be used while controlling the robot via\\n                                             // angle.\\n    swerveDrive.setCosineCompensator(false);// !SwerveDriveTelemetry.isSimulation); // Disables cosine compensation for\\n                                            // simulations since it causes discrepancies not seen in real life.\\n    swerveDrive.setAngularVelocityCompensation(true,\\n        true,\\n        0.1); // Correct for skew that gets worse as angular velocity increases. Start with a\\n              // coefficient of 0.1.\\n    swerveDrive.setModuleEncoderAutoSynchronize(false,\\n        1); // Enable if you want to resynchronize your absolute encoders and motor encoders\\n            // periodically when they are not moving.\\n    //swerveDrive.pushOffsetsToEncoders(); // Set the absolute encoder to be used\\n    // over the internal encoder and push the offsets onto it. Throws warning if not\\n    // possible\\n   \\n    setupPathPlanner();\\n  }\\n\\n  /**\\n   * Construct the swerve drive.\\n   *\\n   * @param driveCfg      SwerveDriveConfiguration for the swerve.\\n   * @param controllerCfg Swerve Controller.\\n   */\\n  public SwerveSubsystem(SwerveDriveConfiguration driveCfg, SwerveControllerConfiguration controllerCfg) {\\n    swerveDrive = new SwerveDrive(driveCfg,\\n        controllerCfg,\\n        Constants.MAX_SPEED,\\n        new Pose2d(new Translation2d(Meter.of(2), Meter.of(0)),\\n            Rotation2d.fromDegrees(0)));\\n  }\\n\\n  /**\\n   * Setup the photon vision class.\\n   */\\n\\n\\n  @Override\\n  public void periodic() {\\n    // When vision is enabled we must manually update odometry in SwerveDrive\\n   \\n  }\\n\\n  @Override\\n  public void simulationPeriodic() {\\n  }\\n\\n  /**\\n   * Setup AutoBuilder for PathPlanner.\\n   */\\n  public void setupPathPlanner() {\\n    // Load the RobotConfig from the GUI settings. You should probably\\n    // store this in your Constants file\\n    RobotConfig config;\\n    try {\\n      config = RobotConfig.fromGUISettings();\\n\\n      final boolean enableFeedforward = true;\\n      // Configure AutoBuilder last\\n      AutoBuilder.configure(\\n          this::getPose,\\n          // Robot pose supplier\\n          this::resetOdometry,\\n          // Method to reset odometry (will be called if your auto has a starting pose)\\n          this::getRobotVelocity,\\n          // ChassisSpeeds supplier. MUST BE ROBOT RELATIVE\\n          (speedsRobotRelative, moduleFeedForwards) -\\u0026gt; {\\n            if (enableFeedforward) {\\n              swerveDrive.drive(\\n                  speedsRobotRelative,\\n                  swerveDrive.kinematics.toSwerveModuleStates(speedsRobotRelative),\\n                  moduleFeedForwards.linearForces());\\n            } else {\\n              swerveDrive.setChassisSpeeds(speedsRobotRelative);\\n            }\\n          },\\n          // Method that will drive the robot given ROBOT RELATIVE ChassisSpeeds. Also\\n          // optionally outputs individual module feedforwards\\n          new PPHolonomicDriveController(\\n              // PPHolonomicController is the built in path following controller for holonomic\\n              // drive trains\\n              new PIDConstants(5.0, 0.0, 0.0),\\n              // Translation PID constants\\n              new PIDConstants(5.0, 0.0, 0.0)\\n          // Rotation PID constants\\n          ),\\n          config,\\n          // The robot configuration\\n          () -\\u0026gt; {\\n            // Boolean supplier that controls when the path will be mirrored for the red\\n            // alliance\\n            // This will flip the path being followed to the red side of the field.\\n            // THE ORIGIN WILL REMAIN ON THE BLUE SIDE\\n\\n            var alliance = DriverStation.getAlliance();\\n            if (alliance.isPresent()) {\\n              return alliance.get() == DriverStation.Alliance.Red;\\n            }\\n            return false;\\n          },\\n          this\\n      // Reference to this subsystem to set requirements\\n      );\\n\\n    } catch (Exception e) {\\n      // Handle exception as needed\\n      e.printStackTrace();\\n    }\\n\\n    // Preload PathPlanner Path finding\\n    // IF USING CUSTOM PATHFINDER ADD BEFORE THIS LINE\\n    PathfindingCommand.warmupCommand().schedule();\\n  }\\n\\n  /**\\n   * Aim the robot at the target returned by PhotonVision.\\n   *\\n   * @return A {@link Command} which will run the alignment.\\n   */\\n  \\n\\n  /**\\n   * Get the path follower with events.\\n   *\\n   * @param pathName PathPlanner path name.\\n   * @return {@link AutoBuilder#followPath(PathPlannerPath)} path command.\\n   */\\n  public Command getAutonomousCommand(String pathName) {\\n    // Create a path following command using AutoBuilder. This will also trigger\\n    // event markers.\\n    return new PathPlannerAuto(pathName);\\n  }\\n\\n  /**\\n   * Use PathPlanner Path finding to go to a point on the field.\\n   *\\n   * @param pose Target {@link Pose2d} to go to.\\n   * @return PathFinding command\\n   */\\n  public Command driveToPose(Pose2d pose) {\\n    // Create the constraints to use while pathfinding\\n    PathConstraints constraints = new PathConstraints(\\n        swerveDrive.getMaximumChassisVelocity(), 4.0,\\n        swerveDrive.getMaximumChassisAngularVelocity(), Units.degreesToRadians(720));\\n\\n    // Since AutoBuilder is configured, we can use it to build pathfinding commands\\n    return AutoBuilder.pathfindToPose(\\n        pose,\\n        constraints,\\n        edu.wpi.first.units.Units.MetersPerSecond.of(0) // Goal end velocity in meters/sec\\n    );\\n  }\\n\\n  /**\\n   * Drive with {@link SwerveSetpointGenerator} from 254, implemented by\\n   * PathPlanner.\\n   *\\n   * @param robotRelativeChassisSpeed Robot relative {@link ChassisSpeeds} to\\n   *                                  achieve.\\n   * @return {@link Command} to run.\\n   * @throws IOException    If the PathPlanner GUI settings is invalid\\n   * @throws ParseException If PathPlanner GUI settings is nonexistent.\\n   */\\n  private Command driveWithSetpointGenerator(Supplier\\u0026lt;ChassisSpeeds\\u0026gt; robotRelativeChassisSpeed)\\n      throws IOException, ParseException {\\n    SwerveSetpointGenerator setpointGenerator = new SwerveSetpointGenerator(RobotConfig.fromGUISettings(),\\n        swerveDrive.getMaximumChassisAngularVelocity());\\n    AtomicReference\\u0026lt;SwerveSetpoint\\u0026gt; prevSetpoint = new AtomicReference\\u0026lt;\\u0026gt;(\\n        new SwerveSetpoint(swerveDrive.getRobotVelocity(),\\n            swerveDrive.getStates(),\\n            DriveFeedforwards.zeros(swerveDrive.getModules().length)));\\n    AtomicReference\\u0026lt;Double\\u0026gt; previousTime = new AtomicReference\\u0026lt;\\u0026gt;();\\n\\n    return startRun(() -\\u0026gt; previousTime.set(Timer.getFPGATimestamp()),\\n        () -\\u0026gt; {\\n          double newTime = Timer.getFPGATimestamp();\\n          SwerveSetpoint newSetpoint = setpointGenerator.generateSetpoint(prevSetpoint.get(),\\n              robotRelativeChassisSpeed.get(),\\n              newTime - previousTime.get());\\n          swerveDrive.drive(newSetpoint.robotRelativeSpeeds(),\\n              newSetpoint.moduleStates(),\\n              newSetpoint.feedforwards().linearForces());\\n          prevSetpoint.set(newSetpoint);\\n          previousTime.set(newTime);\\n\\n        });\\n  }\\n\\n  /**\\n   * Drive with 254's Setpoint generator; port written by PathPlanner.\\n   *\\n   * @param fieldRelativeSpeeds Field-Relative {@link ChassisSpeeds}\\n   * @return Command to drive the robot using the setpoint generator.\\n   */\\n  public Command driveWithSetpointGeneratorFieldRelative(Supplier\\u0026lt;ChassisSpeeds\\u0026gt; fieldRelativeSpeeds) {\\n    try {\\n      return driveWithSetpointGenerator(() -\\u0026gt; {\\n        return ChassisSpeeds.fromFieldRelativeSpeeds(fieldRelativeSpeeds.get(), getHeading());\\n\\n      });\\n    } catch (Exception e) {\\n      DriverStation.reportError(e.toString(), true);\\n    }\\n    return Commands.none();\\n\\n  }\\n\\n  /**\\n   * Command to characterize the robot drive motors using SysId\\n   *\\n   * @return SysId Drive Command\\n   */\\n  public Command sysIdDriveMotorCommand() {\\n    return SwerveDriveTest.generateSysIdCommand(\\n        SwerveDriveTest.setDriveSysIdRoutine(\\n            new Config(),\\n            this, swerveDrive, 12, true),\\n        3.0, 5.0, 3.0);\\n  }\\n\\n  /**\\n   * Command to characterize the robot angle motors using SysId\\n   *\\n   * @return SysId Angle Command\\n   */\\n  public Command sysIdAngleMotorCommand() {\\n    return SwerveDriveTest.generateSysIdCommand(\\n        SwerveDriveTest.setAngleSysIdRoutine(\\n            new Config(),\\n            this, swerveDrive),\\n        3.0, 5.0, 3.0);\\n  }\\n\\n  /**\\n   * Returns a Command that centers the modules of the SwerveDrive subsystem.\\n   *\\n   * @return a Command that centers the modules of the SwerveDrive subsystem\\n   */\\n  public Command centerModulesCommand() {\\n    return run(() -\\u0026gt; Arrays.asList(swerveDrive.getModules())\\n        .forEach(it -\\u0026gt; it.setAngle(0.0)));\\n  }\\n\\n  /**\\n   * Returns a Command that drives the swerve drive to a specific distance at a\\n   * given speed.\\n   *\\n   * @param distanceInMeters       the distance to drive in meters\\n   * @param speedInMetersPerSecond the speed at which to drive in meters per\\n   *                               second\\n   * @return a Command that drives the swerve drive to a specific distance at a\\n   *         given speed\\n   */\\n  public Command driveToDistanceCommand(double distanceInMeters, double speedInMetersPerSecond) {\\n    return run(() -\\u0026gt; drive(new ChassisSpeeds(speedInMetersPerSecond, 0, 0)))\\n        .until(() -\\u0026gt; swerveDrive.getPose().getTranslation().getDistance(new Translation2d(0, 0)) \\u0026gt; distanceInMeters);\\n  }\\n\\n  /**\\n   * Replaces the swerve module feedforward with a new SimpleMotorFeedforward\\n   * object.\\n   *\\n   * @param kS the static gain of the feedforward\\n   * @param kV the velocity gain of the feedforward\\n   * @param kA the acceleration gain of the feedforward\\n   */\\n  public void replaceSwerveModuleFeedforward(double kS, double kV, double kA) {\\n    swerveDrive.replaceSwerveModuleFeedforward(new SimpleMotorFeedforward(kS, kV, kA));\\n  }\\n\\n  /**\\n   * Command to drive the robot using translative values and heading as angular\\n   * velocity.\\n   *\\n   * @param translationX     Translation in the X direction. Cubed for smoother\\n   *                         controls.\\n   * @param translationY     Translation in the Y direction. Cubed for smoother\\n   *                         controls.\\n   * @param angularRotationX Angular velocity of the robot to set. Cubed for\\n   *                         smoother controls.\\n   * @return Drive command.\\n   */\\n  public Command driveCommand(DoubleSupplier translationX, DoubleSupplier translationY,\\n      DoubleSupplier angularRotationX) {\\n    return run(() -\\u0026gt; {\\n      // Make the robot move\\n      swerveDrive.drive(SwerveMath.scaleTranslation(new Translation2d(\\n          translationX.getAsDouble() * swerveDrive.getMaximumChassisVelocity(),\\n          translationY.getAsDouble() * swerveDrive.getMaximumChassisVelocity()), 0.8),\\n          Math.pow(angularRotationX.getAsDouble(), 3) * swerveDrive.getMaximumChassisAngularVelocity(),\\n          true,\\n          false);\\n    });\\n  }\\n\\n  /**\\n   * Command to drive the robot using translative values and heading as a\\n   * setpoint.\\n   *\\n   * @param translationX Translation in the X direction. Cubed for smoother\\n   *                     controls.\\n   * @param translationY Translation in the Y direction. Cubed for smoother\\n   *                     controls.\\n   * @param headingX     Heading X to calculate angle of the joystick.\\n   * @param headingY     Heading Y to calculate angle of the joystick.\\n   * @return Drive command.\\n   */\\n  public Command driveCommand(DoubleSupplier translationX, DoubleSupplier translationY, DoubleSupplier headingX,\\n      DoubleSupplier headingY) {\\n    // swerveDrive.setHeadingCorrection(true); // Normally you would want heading\\n    // correction for this kind of control.\\n    return run(() -\\u0026gt; {\\n\\n      Translation2d scaledInputs = SwerveMath.scaleTranslation(new Translation2d(translationX.getAsDouble(),\\n          translationY.getAsDouble()), 0.8);\\n\\n      // Make the robot move\\n      driveFieldOriented(swerveDrive.swerveController.getTargetSpeeds(scaledInputs.getX(), scaledInputs.getY(),\\n          headingX.getAsDouble(),\\n          headingY.getAsDouble(),\\n          swerveDrive.getOdometryHeading().getRadians(),\\n          swerveDrive.getMaximumChassisVelocity()));\\n    });\\n  }\\n\\n  /**\\n   * The primary method for controlling the drivebase. Takes a\\n   * {@link Translation2d} and a rotation rate, and\\n   * calculates and commands module states accordingly. Can use either open-loop\\n   * or closed-loop velocity control for\\n   * the wheel velocities. Also has field- and robot-relative modes, which affect\\n   * how the translation vector is used.\\n   *\\n   * @param translation   {@link Translation2d} that is the commanded linear\\n   *                      velocity of the robot, in meters per\\n   *                      second. In robot-relative mode, positive x is torwards\\n   *                      the bow (front) and positive y is\\n   *                      torwards port (left). In field-relative mode, positive x\\n   *                      is away from the alliance wall\\n   *                      (field North) and positive y is torwards the left wall\\n   *                      when looking through the driver station\\n   *                      glass (field West).\\n   * @param rotation      Robot angular rate, in radians per second. CCW positive.\\n   *                      Unaffected by field/robot\\n   *                      relativity.\\n   * @param fieldRelative Drive mode. True for field-relative, false for\\n   *                      robot-relative.\\n   */\\n  public void drive(Translation2d translation, double rotation, boolean fieldRelative) {\\n    swerveDrive.drive(translation,\\n        rotation,\\n        fieldRelative,\\n        false); // Open loop is disabled since it shouldn't be used most of the time.\\n  }\\n\\n  /**\\n   * Drive the robot given a chassis field oriented velocity.\\n   *\\n   * @param velocity Velocity according to the field.\\n   */\\n  public void driveFieldOriented(ChassisSpeeds velocity) {\\n    swerveDrive.driveFieldOriented(velocity);\\n  }\\n\\n  /**\\n   * Drive the robot given a chassis field oriented velocity.\\n   *\\n   * @param velocity Velocity according to the field.\\n   */\\n  public Command driveFieldOriented(Supplier\\u0026lt;ChassisSpeeds\\u0026gt; velocity) {\\n    return run(() -\\u0026gt; {\\n      swerveDrive.driveFieldOriented(velocity.get());\\n    });\\n  }\\n\\n  /**\\n   * Drive according to the chassis robot oriented velocity.\\n   *\\n   * @param velocity Robot oriented {@link ChassisSpeeds}\\n   */\\n  public void drive(ChassisSpeeds velocity) {\\n    swerveDrive.drive(velocity);\\n  }\\n\\n  /**\\n   * Get the swerve drive kinematics object.\\n   *\\n   * @return {@link SwerveDriveKinematics} of the swerve drive.\\n   */\\n  public SwerveDriveKinematics getKinematics() {\\n    return swerveDrive.kinematics;\\n  }\\n\\n  /**\\n   * Resets odometry to the given pose. Gyro angle and module positions do not\\n   * need to be reset when calling this\\n   * method. However, if either gyro angle or module position is reset, this must\\n   * be called in order for odometry to\\n   * keep working.\\n   *\\n   * @param initialHolonomicPose The pose to set the odometry to\\n   */\\n  public void resetOdometry(Pose2d initialHolonomicPose) {\\n    swerveDrive.resetOdometry(initialHolonomicPose);\\n  }\\n\\n  /**\\n   * Gets the current pose (position and rotation) of the robot, as reported by\\n   * odometry.\\n   *\\n   * @return The robot's pose\\n   */\\n  public Pose2d getPose() {\\n    return swerveDrive.getPose();\\n  }\\n\\n  /**\\n   * Set chassis speeds with closed-loop velocity control.\\n   *\\n   * @param chassisSpeeds Chassis Speeds to set.\\n   */\\n  public void setChassisSpeeds(ChassisSpeeds chassisSpeeds) {\\n    swerveDrive.setChassisSpeeds(chassisSpeeds);\\n  }\\n\\n  /**\\n   * Post the trajectory to the field.\\n   *\\n   * @param trajectory The trajectory to post.\\n   */\\n  public void postTrajectory(Trajectory trajectory) {\\n    swerveDrive.postTrajectory(trajectory);\\n  }\\n\\n  /**\\n   * Resets the gyro angle to zero and resets odometry to the same position, but\\n   * facing toward 0.\\n   */\\n  public void zeroGyro() {\\n    swerveDrive.zeroGyro();\\n  }\\n\\n  /**\\n   * Checks if the alliance is red, defaults to false if alliance isn't available.\\n   *\\n   * @return true if the red alliance, false if blue. Defaults to false if none is\\n   *         available.\\n   */\\n  private boolean isRedAlliance() {\\n    var alliance = DriverStation.getAlliance();\\n    return alliance.isPresent() ? alliance.get() == DriverStation.Alliance.Red : false;\\n  }\\n\\n  /**\\n   * This will zero (calibrate) the robot to assume the current position is facing\\n   * forward\\n   * \\u0026lt;p\\u0026gt;\\n   * If red alliance rotate the robot 180 after the drviebase zero command\\n   */\\n  public void zeroGyroWithAlliance() {\\n    if (isRedAlliance()) {\\n      zeroGyro();\\n      // Set the pose 180 degrees\\n      resetOdometry(new Pose2d(getPose().getTranslation(), Rotation2d.fromDegrees(180)));\\n    } else {\\n      zeroGyro();\\n    }\\n  }\\n\\n  /**\\n   * Sets the drive motors to brake/coast mode.\\n   *\\n   * @param brake True to set motors to brake mode, false for coast.\\n   */\\n  public void setMotorBrake(boolean brake) {\\n    swerveDrive.setMotorIdleMode(brake);\\n  }\\n\\n  /**\\n   * Gets the current yaw angle of the robot, as reported by the swerve pose\\n   * estimator in the underlying drivebase.\\n   * Note, this is not the raw gyro reading, this may be corrected from calls to\\n   * resetOdometry().\\n   *\\n   * @return The yaw angle\\n   */\\n  public Rotation2d getHeading() {\\n    return getPose().getRotation();\\n  }\\n\\n  /**\\n   * Get the chassis speeds based on controller input of 2 joysticks. One for\\n   * speeds in which direction. The other for\\n   * the angle of the robot.\\n   *\\n   * @param xInput   X joystick input for the robot to move in the X direction.\\n   * @param yInput   Y joystick input for the robot to move in the Y direction.\\n   * @param headingX X joystick which controls the angle of the robot.\\n   * @param headingY Y joystick which controls the angle of the robot.\\n   * @return {@link ChassisSpeeds} which can be sent to the Swerve Drive.\\n   */\\n  public ChassisSpeeds getTargetSpeeds(double xInput, double yInput, double headingX, double headingY) {\\n    Translation2d scaledInputs = SwerveMath.cubeTranslation(new Translation2d(xInput, yInput));\\n    return swerveDrive.swerveController.getTargetSpeeds(scaledInputs.getX(),\\n        scaledInputs.getY(),\\n        headingX,\\n        headingY,\\n        getHeading().getRadians(),\\n        Constants.MAX_SPEED);\\n  }\\n\\n  /**\\n   * Get the chassis speeds based on controller input of 1 joystick and one angle.\\n   * Control the robot at an offset of\\n   * 90deg.\\n   *\\n   * @param xInput X joystick input for the robot to move in the X direction.\\n   * @param yInput Y joystick input for the robot to move in the Y direction.\\n   * @param angle  The angle in as a {@link Rotation2d}.\\n   * @return {@link ChassisSpeeds} which can be sent to the Swerve Drive.\\n   */\\n  public ChassisSpeeds getTargetSpeeds(double xInput, double yInput, Rotation2d angle) {\\n    Translation2d scaledInputs = SwerveMath.cubeTranslation(new Translation2d(xInput, yInput));\\n\\n    return swerveDrive.swerveController.getTargetSpeeds(scaledInputs.getX(),\\n        scaledInputs.getY(),\\n        angle.getRadians(),\\n        getHeading().getRadians(),\\n        Constants.MAX_SPEED);\\n  }\\n\\n  /**\\n   * Gets the current field-relative velocity (x, y and omega) of the robot\\n   *\\n   * @return A ChassisSpeeds object of the current field-relative velocity\\n   */\\n  public ChassisSpeeds getFieldVelocity() {\\n    return swerveDrive.getFieldVelocity();\\n  }\\n\\n  /**\\n   * Gets the current velocity (x, y and omega) of the robot\\n   *\\n   * @return A {@link ChassisSpeeds} object of the current velocity\\n   */\\n  public ChassisSpeeds getRobotVelocity() {\\n    return swerveDrive.getRobotVelocity();\\n  }\\n\\n  /**\\n   * Get the {@link SwerveController} in the swerve drive.\\n   *\\n   * @return {@link SwerveController} from the {@link SwerveDrive}.\\n   */\\n  public SwerveController getSwerveController() {\\n    return swerveDrive.swerveController;\\n  }\\n\\n  /**\\n   * Get the {@link SwerveDriveConfiguration} object.\\n   *\\n   * @return The {@link SwerveDriveConfiguration} fpr the current drive.\\n   */\\n  public SwerveDriveConfiguration getSwerveDriveConfiguration() {\\n    return swerveDrive.swerveDriveConfiguration;\\n  }\\n\\n  /**\\n   * Lock the swerve drive to prevent it from moving.\\n   */\\n  public void lock() {\\n    swerveDrive.lockPose();\\n  }\\n\\n  /**\\n   * Gets the current pitch angle of the robot, as reported by the imu.\\n   *\\n   * @return The heading as a {@link Rotation2d} angle\\n   */\\n  public Rotation2d getPitch() {\\n    return swerveDrive.getPitch();\\n  }\\n\\n  /**\\n   * Add a fake vision reading for testing purposes.\\n   */\\n  \\n\\n  /**\\n   * Gets the swerve drive object.\\n   *\\n   * @return {@link SwerveDrive}\\n   */\\n  public SwerveDrive getSwerveDrive() {\\n    return swerveDrive;\\n  }\\n}\\n\\n\\u003c/code\\u003e\\u003c/pre\\u003e\\n\\u003cp\\u003eAgain, all I want ideally is for the heading to be the tx value instead of being the value from the joystick.\\u003c/p\\u003e\",\"post_number\":1,\"post_type\":1,\"posts_count\":3,\"updated_at\":\"2025-03-11T18:09:13.657Z\",\"reply_count\":0,\"reply_to_post_number\":null,\"quote_count\":0,\"incoming_link_count\":52,\"reads\":92,\"readers_count\":91,\"score\":278.4,\"yours\":false,\"topic_id\":495184,\"topic_slug\":\"limelight-swerving-robot-to-point-at-apriltag-yagsl\",\"display_username\":\"Daniel McLaughlin\",\"primary_group_name\":null,\"flair_name\":null,\"flair_url\":null,\"flair_bg_color\":null,\"flair_color\":null,\"flair_group_id\":null,\"badges_granted\":[],\"version\":1,\"can_edit\":false,\"can_delete\":false,\"can_recover\":false,\"can_see_hidden_post\":true,\"can_wiki\":false,\"read\":true,\"user_title\":null,\"bookmarked\":false,\"actions_summary\":[],\"moderator\":false,\"admin\":false,\"staff\":false,\"user_id\":69324,\"hidden\":false,\"trust_level\":1,\"deleted_at\":null,\"user_deleted\":false,\"edit_reason\":null,\"can_view_edit_history\":true,\"wiki\":false,\"post_url\":\"/t/limelight-swerving-robot-to-point-at-apriltag-yagsl/495184/1\",\"reactions\":[],\"current_user_reaction\":null,\"reaction_users_count\":0,\"current_user_used_main_reaction\":false,\"can_accept_answer\":false,\"can_unaccept_answer\":false,\"accepted_answer\":false,\"topic_accepted_answer\":null},{\"id\":3554633,\"name\":\"Daniel McLaughlin\",\"username\":\"Pieyama_Pieman\",\"avatar_template\":\"/user_avatar/www.chiefdelphi.com/pieyama_pieman/{size}/242065_2.png\",\"created_at\":\"2025-03-12T00:13:13.751Z\",\"cooked\":\"\\u003cp\\u003eThe end goal is to be able to package this command so that it can be triggered by a button press, upon locating the reef april tag.\\u003c/p\\u003e\",\"post_number\":2,\"post_type\":1,\"posts_count\":3,\"updated_at\":\"2025-03-12T00:13:13.751Z\",\"reply_count\":1,\"reply_to_post_number\":null,\"quote_count\":0,\"incoming_link_count\":1,\"reads\":56,\"readers_count\":55,\"score\":21.2,\"yours\":false,\"topic_id\":495184,\"topic_slug\":\"limelight-swerving-robot-to-point-at-apriltag-yagsl\",\"display_username\":\"Daniel McLaughlin\",\"primary_group_name\":null,\"flair_name\":null,\"flair_url\":null,\"flair_bg_color\":null,\"flair_color\":null,\"flair_group_id\":null,\"badges_granted\":[],\"version\":1,\"can_edit\":false,\"can_delete\":false,\"can_recover\":false,\"can_see_hidden_post\":true,\"can_wiki\":false,\"read\":true,\"user_title\":null,\"bookmarked\":false,\"actions_summary\":[],\"moderator\":false,\"admin\":false,\"staff\":false,\"user_id\":69324,\"hidden\":false,\"trust_level\":1,\"deleted_at\":null,\"user_deleted\":false,\"edit_reason\":null,\"can_view_edit_history\":true,\"wiki\":false,\"post_url\":\"/t/limelight-swerving-robot-to-point-at-apriltag-yagsl/495184/2\",\"reactions\":[],\"current_user_reaction\":null,\"reaction_users_count\":0,\"current_user_used_main_reaction\":false,\"can_accept_answer\":false,\"can_unaccept_answer\":false,\"accepted_answer\":false,\"topic_accepted_answer\":null},{\"id\":3554752,\"name\":\"SLAB-Mr.Thomas\",\"username\":\"SLAB-Mr.Thomas\",\"avatar_template\":\"/user_avatar/www.chiefdelphi.com/slab-mr.thomas/{size}/182153_2.png\",\"created_at\":\"2025-03-12T02:34:24.762Z\",\"cooked\":\"\\u003cp\\u003eSounds like you want the \\u003cspan class=\\\"abbreviation\\\"\\u003eLL\\u003ctemplate class=\\\"tooltiptext\\\" data-text=\\\"Limelight, an integrated vision coprocessor\\\"\\u003e\\u003c/template\\u003e\\u003c/span\\u003e \\u003ca href=\\\"https://docs.limelightvision.io/docs/docs-limelight/tutorials/tutorial-aiming-with-visual-servoing\\\" rel=\\\"noopener nofollow ugc\\\"\\u003eservoing technique\\u003c/a\\u003e\\u003c/p\\u003e\",\"post_number\":3,\"post_type\":1,\"posts_count\":3,\"updated_at\":\"2025-03-12T02:34:24.762Z\",\"reply_count\":0,\"reply_to_post_number\":2,\"quote_count\":0,\"incoming_link_count\":0,\"reads\":46,\"readers_count\":45,\"score\":9.2,\"yours\":false,\"topic_id\":495184,\"topic_slug\":\"limelight-swerving-robot-to-point-at-apriltag-yagsl\",\"display_username\":\"SLAB-Mr.Thomas\",\"primary_group_name\":null,\"flair_name\":null,\"flair_url\":null,\"flair_bg_color\":null,\"flair_color\":null,\"flair_group_id\":null,\"badges_granted\":[],\"version\":1,\"can_edit\":false,\"can_delete\":false,\"can_recover\":false,\"can_see_hidden_post\":true,\"can_wiki\":false,\"link_counts\":[{\"url\":\"https://docs.limelightvision.io/docs/docs-limelight/tutorials/tutorial-aiming-with-visual-servoing\",\"internal\":false,\"reflection\":false,\"title\":\"Aiming With Visual Servoing | Limelight Documentation\",\"clicks\":33}],\"read\":true,\"user_title\":\"\",\"reply_to_user\":{\"id\":69324,\"username\":\"Pieyama_Pieman\",\"name\":\"Daniel McLaughlin\",\"avatar_template\":\"/user_avatar/www.chiefdelphi.com/pieyama_pieman/{size}/242065_2.png\"},\"bookmarked\":false,\"actions_summary\":[],\"moderator\":false,\"admin\":false,\"staff\":false,\"user_id\":24594,\"hidden\":false,\"trust_level\":2,\"deleted_at\":null,\"user_deleted\":false,\"edit_reason\":null,\"can_view_edit_history\":true,\"wiki\":false,\"user_custom_fields\":{\"user_field_4\":\"\"},\"post_url\":\"/t/limelight-swerving-robot-to-point-at-apriltag-yagsl/495184/3\",\"reactions\":[],\"current_user_reaction\":null,\"reaction_users_count\":0,\"current_user_used_main_reaction\":false,\"can_accept_answer\":false,\"can_unaccept_answer\":false,\"accepted_answer\":false,\"topic_accepted_answer\":null}],\"stream\":[3554300,3554633,3554752]},\"timeline_lookup\":[[1,145]],\"suggested_topics\":[{\"id\":473432,\"title\":\"Pathplanner with Romi/XRP robots\",\"fancy_title\":\"Pathplanner with Romi/XRP robots\",\"slug\":\"pathplanner-with-romi-xrp-robots\",\"posts_count\":3,\"reply_count\":1,\"highest_post_number\":3,\"image_url\":null,\"created_at\":\"2024-10-22T14:28:34.234Z\",\"last_posted_at\":\"2024-10-22T15:23:24.880Z\",\"bumped\":true,\"bumped_at\":\"2024-10-22T15:23:24.880Z\",\"archetype\":\"regular\",\"unseen\":false,\"pinned\":false,\"unpinned\":null,\"excerpt\":\"Has anyone ever used path planner with Romi robots or the XRP platform? We have Romi bots and just bought 2 XRP robots, and I am implementing it in code now, but was wondering if anyone else has done …\",\"visible\":true,\"closed\":false,\"archived\":false,\"bookmarked\":null,\"liked\":null,\"tags\":[],\"tags_descriptions\":{},\"like_count\":3,\"views\":159,\"category_id\":30,\"featured_link\":null,\"has_accepted_answer\":false,\"sidecar_installed\":true,\"include_dominant_colour\":false,\"topic_post_id\":3437673,\"topic_post_liked\":false,\"topic_post_can_like\":false,\"topic_post_can_unlike\":false,\"topic_post_bookmarked\":false,\"topic_post_is_current_users\":null,\"topic_post_number\":1,\"topic_post_user\":{\"id\":57833,\"username\":\"hjmcphail76\",\"name\":\"Harrison\",\"avatar_template\":\"/user_avatar/www.chiefdelphi.com/hjmcphail76/{size}/234713_2.png\"},\"posters\":[{\"extras\":\"latest\",\"description\":\"Original Poster, Most Recent Poster\",\"user\":{\"id\":57833,\"username\":\"hjmcphail76\",\"name\":\"Harrison\",\"avatar_template\":\"/user_avatar/www.chiefdelphi.com/hjmcphail76/{size}/234713_2.png\",\"trust_level\":2}},{\"extras\":null,\"description\":\"Frequent Poster\",\"user\":{\"id\":2695,\"username\":\"ngreen\",\"name\":\"Nelson Green (1108 Mentor Coach Electrical Programming)\",\"avatar_template\":\"/user_avatar/www.chiefdelphi.com/ngreen/{size}/264478_2.png\",\"trust_level\":2}}]},{\"id\":474597,\"title\":\"CTRE Motion Magic Expo Control\",\"fancy_title\":\"CTRE Motion Magic Expo Control\",\"slug\":\"ctre-motion-magic-expo-control\",\"posts_count\":4,\"reply_count\":2,\"highest_post_number\":4,\"image_url\":null,\"created_at\":\"2024-11-09T18:27:00.113Z\",\"last_posted_at\":\"2025-02-07T06:14:42.183Z\",\"bumped\":true,\"bumped_at\":\"2025-02-07T06:14:42.183Z\",\"archetype\":\"regular\",\"unseen\":false,\"pinned\":false,\"unpinned\":null,\"excerpt\":\"Almost all motion magic expo control comments indicate voltage control, but what about current. So knowing that you need kv, ka for expo control you could determine that from sysId with either voltag…\",\"visible\":true,\"closed\":false,\"archived\":false,\"bookmarked\":null,\"liked\":null,\"tags\":[],\"tags_descriptions\":{},\"like_count\":0,\"views\":638,\"category_id\":30,\"featured_link\":null,\"has_accepted_answer\":false,\"sidecar_installed\":true,\"include_dominant_colour\":false,\"topic_post_id\":3445417,\"topic_post_liked\":false,\"topic_post_can_like\":false,\"topic_post_can_unlike\":false,\"topic_post_bookmarked\":false,\"topic_post_is_current_users\":null,\"topic_post_number\":1,\"topic_post_user\":{\"id\":48345,\"username\":\"narmstro\",\"name\":\"Nicholas Armstrong\",\"avatar_template\":\"/letter_avatar_proxy/v4/letter/n/5e9695/{size}.png\"},\"posters\":[{\"extras\":null,\"description\":\"Original Poster\",\"user\":{\"id\":48345,\"username\":\"narmstro\",\"name\":\"Nicholas Armstrong\",\"avatar_template\":\"/letter_avatar_proxy/v4/letter/n/5e9695/{size}.png\",\"trust_level\":2}},{\"extras\":null,\"description\":\"Frequent Poster\",\"user\":{\"id\":48146,\"username\":\"bhall-ctre\",\"name\":\"Benjamin Hall\",\"avatar_template\":\"/user_avatar/www.chiefdelphi.com/bhall-ctre/{size}/198180_2.png\",\"primary_group_name\":\"CTRE\",\"flair_name\":\"CTRE\",\"flair_url\":\"/uploads/default/original/3X/1/b/1bd2b430e1bb6427d1c6504ff6abcd31de851a6d.png\",\"flair_group_id\":57,\"trust_level\":2}},{\"extras\":\"latest\",\"description\":\"Most Recent Poster\",\"user\":{\"id\":69803,\"username\":\"ez500\",\"name\":\"Eugene Zhang\",\"avatar_template\":\"/letter_avatar_proxy/v4/letter/e/bc8723/{size}.png\",\"trust_level\":2}}]},{\"id\":483180,\"title\":\"NavX switches ports\",\"fancy_title\":\"NavX switches ports\",\"slug\":\"navx-switches-ports\",\"posts_count\":4,\"reply_count\":2,\"highest_post_number\":4,\"image_url\":null,\"created_at\":\"2025-01-23T06:50:12.605Z\",\"last_posted_at\":\"2025-01-23T19:05:52.041Z\",\"bumped\":true,\"bumped_at\":\"2025-01-23T19:05:52.041Z\",\"archetype\":\"regular\",\"unseen\":false,\"pinned\":false,\"unpinned\":null,\"excerpt\":\"If you’re plugged into the MXP port, you don’t need the separate USB cable or kUSB*. You can use SPI.Port.kMXP instead (unless the library changed… I can’t seem to find docs referencing 2024 or newer…\",\"visible\":true,\"closed\":false,\"archived\":false,\"bookmarked\":null,\"liked\":null,\"tags\":[],\"tags_descriptions\":{},\"like_count\":1,\"views\":92,\"category_id\":30,\"featured_link\":null,\"has_accepted_answer\":true,\"sidecar_installed\":true,\"include_dominant_colour\":false,\"topic_post_id\":3490538,\"topic_post_liked\":false,\"topic_post_can_like\":false,\"topic_post_can_unlike\":false,\"topic_post_bookmarked\":false,\"topic_post_is_current_users\":null,\"topic_post_number\":2,\"topic_post_user\":{\"id\":9105,\"username\":\"Fletch1373\",\"name\":\"Fletch\",\"avatar_template\":\"/user_avatar/www.chiefdelphi.com/fletch1373/{size}/220073_2.png\"},\"posters\":[{\"extras\":null,\"description\":\"Original Poster\",\"user\":{\"id\":64351,\"username\":\"GronkBaby\",\"name\":\"Emil\",\"avatar_template\":\"/letter_avatar_proxy/v4/letter/g/ba8739/{size}.png\",\"trust_level\":2}},{\"extras\":null,\"description\":\"Frequent Poster, Accepted Answer\",\"user\":{\"id\":9105,\"username\":\"Fletch1373\",\"name\":\"Fletch\",\"avatar_template\":\"/user_avatar/www.chiefdelphi.com/fletch1373/{size}/220073_2.png\",\"trust_level\":2}},{\"extras\":\"latest\",\"description\":\"Most Recent Poster\",\"user\":{\"id\":25570,\"username\":\"alst\",\"name\":\"alst\",\"avatar_template\":\"/user_avatar/www.chiefdelphi.com/alst/{size}/11646_2.png\",\"trust_level\":2}}]},{\"id\":483692,\"title\":\"Limelight Programming Import Error\",\"fancy_title\":\"Limelight Programming Import Error\",\"slug\":\"limelight-programming-import-error\",\"posts_count\":4,\"reply_count\":2,\"highest_post_number\":4,\"image_url\":\"https://www.chiefdelphi.com/uploads/default/optimized/3X/4/5/4515d3b892e29f3577544c26380f8c17667b0e15_2_1024x655.png\",\"created_at\":\"2025-01-26T15:13:25.299Z\",\"last_posted_at\":\"2025-01-26T17:46:57.774Z\",\"bumped\":true,\"bumped_at\":\"2025-01-26T17:46:57.774Z\",\"archetype\":\"regular\",\"unseen\":false,\"pinned\":false,\"unpinned\":null,\"excerpt\":\"I think your file is not on the folder specified by the import. Try putting it on the same folder as the robot.java file and see if this fixes it. If that’s the case, I believe you should change the i…\",\"visible\":true,\"closed\":false,\"archived\":false,\"bookmarked\":null,\"liked\":null,\"tags\":[],\"tags_descriptions\":{},\"like_count\":0,\"views\":96,\"category_id\":30,\"featured_link\":null,\"has_accepted_answer\":true,\"sidecar_installed\":true,\"include_dominant_colour\":false,\"topic_post_id\":3493017,\"topic_post_liked\":false,\"topic_post_can_like\":false,\"topic_post_can_unlike\":false,\"topic_post_bookmarked\":false,\"topic_post_is_current_users\":null,\"topic_post_number\":2,\"topic_post_user\":{\"id\":63359,\"username\":\"predobrega\",\"name\":\"Pedro Braga\",\"avatar_template\":\"/user_avatar/www.chiefdelphi.com/predobrega/{size}/211207_2.png\"},\"posters\":[{\"extras\":null,\"description\":\"Original Poster\",\"user\":{\"id\":70504,\"username\":\"AutumnPlanet\",\"name\":null,\"avatar_template\":\"/user_avatar/www.chiefdelphi.com/autumnplanet/{size}/260647_2.png\",\"trust_level\":2}},{\"extras\":null,\"description\":\"Frequent Poster, Accepted Answer\",\"user\":{\"id\":63359,\"username\":\"predobrega\",\"name\":\"Pedro Braga\",\"avatar_template\":\"/user_avatar/www.chiefdelphi.com/predobrega/{size}/211207_2.png\",\"trust_level\":2}},{\"extras\":\"latest\",\"description\":\"Most Recent Poster\",\"user\":{\"id\":24594,\"username\":\"SLAB-Mr.Thomas\",\"name\":\"SLAB-Mr.Thomas\",\"avatar_template\":\"/user_avatar/www.chiefdelphi.com/slab-mr.thomas/{size}/182153_2.png\",\"trust_level\":2}}]},{\"id\":471191,\"title\":\"Swerve bot not cooperating with PathPlanner\",\"fancy_title\":\"Swerve bot not cooperating with PathPlanner\",\"slug\":\"swerve-bot-not-cooperating-with-pathplanner\",\"posts_count\":19,\"reply_count\":16,\"highest_post_number\":19,\"image_url\":null,\"created_at\":\"2024-09-13T19:20:27.682Z\",\"last_posted_at\":\"2024-09-23T22:51:11.521Z\",\"bumped\":true,\"bumped_at\":\"2024-09-23T22:51:11.521Z\",\"archetype\":\"regular\",\"unseen\":false,\"pinned\":false,\"unpinned\":null,\"excerpt\":\"We figured out the issue. Turns out the line of code that creates an instance of RobotContainer in Robot.java got deleted by accident at some point during testing. Thank you for your help though!\",\"visible\":true,\"closed\":false,\"archived\":false,\"bookmarked\":null,\"liked\":null,\"tags\":[\"robot\"],\"tags_descriptions\":{},\"like_count\":3,\"views\":362,\"category_id\":30,\"featured_link\":null,\"has_accepted_answer\":true,\"sidecar_installed\":true,\"include_dominant_colour\":false,\"topic_post_id\":3426528,\"topic_post_liked\":false,\"topic_post_like_count\":2,\"topic_post_can_like\":false,\"topic_post_can_unlike\":false,\"topic_post_bookmarked\":false,\"topic_post_is_current_users\":null,\"topic_post_number\":19,\"topic_post_user\":{\"id\":27413,\"username\":\"karin.gill123\",\"name\":\"k.gill\",\"avatar_template\":\"/letter_avatar_proxy/v4/letter/k/f07891/{size}.png\"},\"posters\":[{\"extras\":\"latest\",\"description\":\"Original Poster, Most Recent Poster, Accepted Answer\",\"user\":{\"id\":27413,\"username\":\"karin.gill123\",\"name\":\"k.gill\",\"avatar_template\":\"/letter_avatar_proxy/v4/letter/k/f07891/{size}.png\",\"trust_level\":2}},{\"extras\":null,\"description\":\"Frequent Poster\",\"user\":{\"id\":51887,\"username\":\"nstrike\",\"name\":\"\",\"avatar_template\":\"/user_avatar/www.chiefdelphi.com/nstrike/{size}/167038_2.png\",\"trust_level\":2}},{\"extras\":null,\"description\":\"Frequent Poster\",\"user\":{\"id\":63857,\"username\":\"Aditya9246\",\"name\":\"Aditya Gajula\",\"avatar_template\":\"/letter_avatar_proxy/v4/letter/a/fbc32d/{size}.png\",\"trust_level\":2}},{\"extras\":null,\"description\":\"Frequent Poster\",\"user\":{\"id\":65876,\"username\":\"bobotics\",\"name\":\"Kevin\",\"avatar_template\":\"/user_avatar/www.chiefdelphi.com/bobotics/{size}/223603_2.png\",\"trust_level\":2}},{\"extras\":null,\"description\":\"Frequent Poster\",\"user\":{\"id\":38743,\"username\":\"bovlb\",\"name\":\"Gavin Matthews\",\"avatar_template\":\"/user_avatar/www.chiefdelphi.com/bovlb/{size}/167232_2.png\",\"trust_level\":2}}]}],\"tags\":[\"limelight\"],\"tags_descriptions\":{},\"id\":495184,\"title\":\"Limelight swerving robot to point at AprilTag (YAGSL)\",\"fancy_title\":\"Limelight swerving robot to point at AprilTag (YAGSL)\",\"posts_count\":3,\"created_at\":\"2025-03-11T18:09:13.569Z\",\"views\":181,\"reply_count\":1,\"like_count\":0,\"last_posted_at\":\"2025-03-12T02:34:24.762Z\",\"visible\":true,\"closed\":false,\"archived\":false,\"has_summary\":false,\"archetype\":\"regular\",\"slug\":\"limelight-swerving-robot-to-point-at-apriltag-yagsl\",\"category_id\":30,\"word_count\":3102,\"deleted_at\":null,\"user_id\":69324,\"featured_link\":null,\"pinned_globally\":false,\"pinned_at\":null,\"pinned_until\":null,\"image_url\":null,\"slow_mode_seconds\":0,\"draft\":null,\"draft_key\":\"topic_495184\",\"draft_sequence\":null,\"unpinned\":null,\"pinned\":false,\"current_post_number\":1,\"highest_post_number\":3,\"deleted_by\":null,\"actions_summary\":[{\"id\":4,\"count\":0,\"hidden\":false,\"can_act\":false},{\"id\":8,\"count\":0,\"hidden\":false,\"can_act\":false},{\"id\":10,\"count\":0,\"hidden\":false,\"can_act\":false},{\"id\":7,\"count\":0,\"hidden\":false,\"can_act\":false}],\"chunk_size\":20,\"bookmarked\":false,\"topic_timer\":{\"id\":45367,\"execute_at\":\"2026-03-12T02:34:24.762Z\",\"duration_minutes\":525600,\"based_on_last_post\":true,\"status_type\":\"close\",\"category_id\":null},\"message_bus_last_id\":0,\"participant_count\":2,\"show_read_indicator\":false,\"thumbnails\":null,\"slow_mode_enabled_until\":null,\"valid_reactions\":[\"heart\",\"laughing\",\"point_up\",\"+1\",\"-1\",\"100\",\"open_mouth\",\"cry\",\"question\",\"thinking\",\"call_me_hand\",\"hugs\",\"angry\"],\"user_chosen_thumbnail_url\":null,\"sidecar_installed\":true,\"details\":{\"can_edit\":false,\"notification_level\":1,\"participants\":[{\"id\":69324,\"username\":\"Pieyama_Pieman\",\"name\":\"Daniel McLaughlin\",\"avatar_template\":\"/user_avatar/www.chiefdelphi.com/pieyama_pieman/{size}/242065_2.png\",\"post_count\":2,\"primary_group_name\":null,\"flair_name\":null,\"flair_url\":null,\"flair_color\":null,\"flair_bg_color\":null,\"flair_group_id\":null,\"trust_level\":1},{\"id\":24594,\"username\":\"SLAB-Mr.Thomas\",\"name\":\"SLAB-Mr.Thomas\",\"avatar_template\":\"/user_avatar/www.chiefdelphi.com/slab-mr.thomas/{size}/182153_2.png\",\"post_count\":1,\"primary_group_name\":null,\"flair_name\":null,\"flair_url\":null,\"flair_color\":null,\"flair_bg_color\":null,\"flair_group_id\":null,\"trust_level\":2}],\"created_by\":{\"id\":69324,\"username\":\"Pieyama_Pieman\",\"name\":\"Daniel McLaughlin\",\"avatar_template\":\"/user_avatar/www.chiefdelphi.com/pieyama_pieman/{size}/242065_2.png\"},\"last_poster\":{\"id\":24594,\"username\":\"SLAB-Mr.Thomas\",\"name\":\"SLAB-Mr.Thomas\",\"avatar_template\":\"/user_avatar/www.chiefdelphi.com/slab-mr.thomas/{size}/182153_2.png\"},\"links\":[{\"url\":\"https://docs.limelightvision.io/docs/docs-limelight/tutorials/tutorial-aiming-with-visual-servoing\",\"title\":\"Aiming With Visual Servoing | Limelight Documentation\",\"internal\":false,\"attachment\":false,\"reflection\":false,\"clicks\":33,\"user_id\":24594,\"domain\":\"docs.limelightvision.io\",\"root_domain\":\"limelightvision.io\"}]},\"bookmarks\":[]}"}
